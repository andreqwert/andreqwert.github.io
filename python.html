<!DOCTYPE html>
<html>
    <head>
        <link href="/assets/themes/green_and_blue.css" rel="stylesheet" type="text/css">
        <meta charset='utf-8'>
        <title>Python notes</title>
    </head>
    
    <body>
    <script src="/assets/rainbow-custom.min.js"></script>
    <p align='justify'>

    <a href='index.html'>Назад</a> <br>

    <h2>Некоторые заметки по Python</h2>
    <h3>По материалам лекций Георгия Курячего и СПБАУ РАН</h3>
        
       
    1. <b>iter</b> - вызывает следующий элемент в кортеже
       
    <pre>
    <code data-language="python">
        c = 23, 234, 23, 2
        a = iter(c)
        next(a)
        >>> 23
        next(a)
        >>> 24
        next(a)
        >>> 23
        next(a)
        >>> 2
        next(a)
        >>> StopIteration
    </code>
    </pre>
    
    2. <b>enumerate</b> - возвращает пару <i>номер_элемента:элемент</i>
    <pre>
    <code data-language="python">
        c = 23, 234, 23, 2
        for i, e in enumerate(c):
            print(i, e)

        >>> 0  23
            1  234
            2  23
            3  2
        </code>
    </pre>
    
    3. <b>reversed</b> - проходит последовательность задом наперёд
    <pre>
    <code data-language="python">
        c = 23, 234, 23, 2
        сс = reversed(c)
        >>> (2, 23, 234, 23)
        </code>
    </pre>
        
    4. <font size="4"><b>zip</b> - делает из последовательностей список пар</font>
    <pre>
    <code data-language="python">
        a,b,c,d = (1,2,3), (4,5,6), (7,8,9), (10,11,12)
        for e in zip(a,b,c,d):
            print(e)
            
        >>> (1, 4, 7, 10)
            (2, 5, 8, 11)
            (3, 6, 9, 12)
        </code>
    </pre>
    
    <h2>Функции</h2>
    <pre>
    <code data-language="python">
        def fun(a, b):
            c = a + 2*b
            # если нет return, то по умолчанию возвращается None
    </code>
    </pre>
        
    Ошибка об отсутствии <i><b>'c'</b></i> появится только после вызова функции:
    <pre>
    <code data-language="python">
        def fun(a, b):
            return a+b+c
            
        fun(9,9)
        >>> NameError: name 'c' is not defined
        
        c=33 
        fun(9,9)
        >>> 51 # если дописать 'c', то функция заработает без ошибок
    </code>
    </pre>
        
    Функции работают и при передаче строковых данных:
    <pre>
    <code data-language="python">
        def fun(a, b):
            return a+b*2
            
        fun('qq','PP')
        
        >>> 'qqPPPP'
    </code>
    </pre>
        
    <h3>Глобальная и локальная видимости переменных</h3>
        
    Допустим, имеется код:
    <pre>
    <code data-language="python">
    def fun(a, b):
        c = a + 2*b
        print(dir())
        return c

    c = 100500
    print(dir())
    fun(1, 2)
    print(c)

    >>> ['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'c', 'fun'] #выводит глобальное пространство имен
        ['a', 'b', 'c'] #выводит локальное пространство имён
        100500
    </code>
    </pre>
    
    Но можно перенести <i><b>c</b></i> в глобальную область видимости. Тогда:
    <pre>
    <code data-language="python">
    def fun(a, b):
        global c
        c = a + 2*b
        print(dir())
        return c

    c = 100500
    print(dir())
    fun(1, 2)
    print(c)

    >>> ['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'c', 'fun'] #выводит глобальное пространство имен
        ['a', 'b'] #выводит локальное пространство имён
        5
    </code>
    </pre>
    
    <h3>Если функция должна принять произвольное число аргументов...</h3>
    ... То можно воспользоваться параметром <b>*args</b>. Таким образом функция принимает сколь угодно много аргументов, а затем производит над ними операции. В данном случае - ищет минимум. 
    <pre>
    <code data-language="python">
    def min(*args):   # type(argc) == tuple
        res = float('inf') # пусть res равен бесконечности
        for arg in args:
            if arg < res:
                res = arg
        return res
    
    >>> min(-5, 12, 13) # -5
    >>> min() # inf
    </code>
    </pre>
    
    Обычно один аргумент указывают обязательным, а остальные - произвольными. Потому что, как правило, некруто возаращать пустое множество. Логичнее было бы, чтобы функция хоть что-то сто́ящее:.

    <pre>
    <code data-language="python">
    def min(first, *args):   # type(argc) == tuple
        res = first
        ...

    >>> min() # missing 1 required argument: 'first'
    </code>
    </pre>
    
    </body>
</html>
