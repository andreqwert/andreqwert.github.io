<!DOCTYPE html>
<html>
    <head>
        <link rel="stylesheet" href="/assets/styles/github.css">
        <meta charset='utf-8'>
        <title>Python notes</title>
    </head>
    
    <body>
    <script src="/assets/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <p align='justify'>

    <a href='index.html'>Назад</a> <br>

    <h2>Некоторые заметки по Python</h2>
    <h3>Генераторы, итераторы и прочие полезности</h3>
        
       
    1. <b>iter</b> - вызывает следующий элемент в кортеже
    <cut>   
    <pre>
    <code class="python">
        c = 23, 234, 23, 2
        a = iter(c)
        next(a)
        >>> 23
        next(a)
        >>> 24
        next(a)
        >>> 23
        next(a)
        >>> 2
        next(a)
        >>> StopIteration
    </code>
    </pre>
    </cut>
        
    2. <b>enumerate</b> - возвращает пару <i>номер_элемента:элемент</i>
    <pre>
    <code class="python">
        c = 23, 234, 23, 2
        for i, e in enumerate(c):
            print(i, e)

        >>> 0  23
            1  234
            2  23
            3  2
        </code>
    </pre>
    
    3. <b>reversed</b> - проходит последовательность задом наперёд
    <pre>
    <code class="python">
        c = 23, 234, 23, 2
        cc = reversed(c)
        >>> (2, 23, 234, 23)
        </code>
    </pre>
        
    4. <font size="4"><b>zip</b> - делает из последовательностей список пар</font>
    <pre>
    <code class="python">
        a,b,c,d = (1,2,3), (4,5,6), (7,8,9), (10,11,12)
        for e in zip(a,b,c,d):
            print(e)
            
        >>> (1, 4, 7, 10)
            (2, 5, 8, 11)
            (3, 6, 9, 12)
        </code>
    </pre>
    
    <h2>Функции</h2>
    <pre>
    <code class="python">
        def fun(a, b):
            c = a + 2*b
            # если нет return, то по умолчанию возвращается None
    </code>
    </pre>
        
    Ошибка об отсутствии <i><b>'c'</b></i> появится только после вызова функции:
    <pre>
    <code class="python">
        def fun(a, b):
            return a+b+c
            
        fun(9,9)
        >>> NameError: name 'c' is not defined
        
        c=33 
        fun(9,9)
        >>> 51 # если дописать 'c', то функция заработает без ошибок
    </code>
    </pre>
        
    Функции работают и при передаче строковых данных:
    <pre>
    <code class="python">
        def fun(a, b):
            return a+b*2
            
        fun('qq','PP')
        
        >>> 'qqPPPP'
    </code>
    </pre>
        
    <h3>Глобальная и локальная видимости переменных</h3>
        
    Допустим, имеется код:
    <pre>
    <code class="python">
    def fun(a, b):
        c = a + 2*b
        print(dir())
        return c

    c = 100500
    print(dir())
    fun(1, 2)
    print(c)

    >>> ['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'c', 'fun'] #выводит глобальное пространство имен
        ['a', 'b', 'c'] #выводит локальное пространство имён
        100500
    </code>
    </pre>
    
    Но можно перенести <i><b>c</b></i> в глобальную область видимости. Тогда:
    <pre>
    <code class="python">
    def fun(a, b):
        global c
        c = a + 2*b
        print(dir())
        return c

    c = 100500
    print(dir())
    fun(1, 2)
    print(c)

    >>> ['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'c', 'fun'] #выводит глобальное пространство имен
        ['a', 'b'] #выводит локальное пространство имён
        5
    </code>
    </pre>
    
    <h3>Если функция должна принять произвольное число аргументов...</h3>
    ... То можно воспользоваться параметром <b>*args</b>. Таким образом функция принимает сколь угодно много аргументов, а затем производит над ними операции. В данном случае - ищет минимум. 
    <pre>
    <code class="python">
    def min(*args):   # type(argc) == tuple
        res = float('inf') # пусть res равен бесконечности
        for arg in args:
            if arg < res:
                res = arg
        return res
    
    >>> min(-5, 12, 13) # -5
    >>> min() # inf
    </code>
    </pre>
    
    Обычно один аргумент указывают обязательным, а остальные - произвольными. Потому что, как правило, некруто возаращать пустое множество. Логичнее было бы, чтобы функция возвращала хоть что-то сто́ящее:.

    <pre>
    <code class="python">
    def min(first, *args):   # type(argc) == tuple
        res = first
        ...

    >>> min() # missing 1 required argument: 'first'
    </code>
    </pre>
    
    <h3>Классы</h3>
    
    <a href='https://www.youtube.com/watch?v=ZDa-Z5JzLYM&t=233s'>Хороший tutorial</a> по классам.
    
    Смысл классов в том, чтобы не писать повторяющийся код, а точнее - не переписывать по отдельности сущности, у которой есть методы.
    Например, данный код является повторяющимся:
    <pre>
    <code class="python">
    class Employee:

        # Каждый сотрудник является экземпляром класса
        pass


    emp_1 = Employee()
    emp_2 = Employee()

    emp_1.firstname = 'Corey'
    emp_1.lastname = 'Schaifer'
    emp_1.email = 'Corey.Schaifer@company.com' 
    emp_1.pay = 50000



    emp_2.firstname = 'Test'
    emp_2.lastname = 'User'
    emp_2.email = 'Test.User@company.com' 
    emp_2.pay = 60000

    print(emp_1.email, emp_2.email)
    </code>
    </pre>
    
    Так вот. Чтобы не писать повторяющийся код, применяют классы. Это нужно в данном примере, в частности, для того, чтобы не переписывать переменные под каждого работника в отдельности.
    С помощью классов можно подать на вход функции всего лишь аргументы о имени-фамилии-почте и з/п. Это также сократит в разы количество кода.

    Более конкретно в данном случае необходима функция <b>__init__</b>.
    Перепишем функцию.
    Согласно общепринятому правилу, первым аргументом является слово <b>self</b> - это слово принадлежности метода к классу.

    <pre>
    <code class="python">
    class Employee:

        def __init__(self, firstname, lastname, pay):
            self.firstname = firstname   # всё равно что "emp_1.firstname = 'Corey'"
            self.lastname = lastname
            self.pay = pay
            self.email = firstname + '.' + lastname + '@company.com'


    emp_1 = Employee('Corey', 'Schaifer', 50000)
    emp_2 = Employee('Test', 'User', 60000)


    print(emp_1.email)
    print(emp_2.email)
    </code>
    </pre>
    
    Можно также добавлять и другие функции - например, можно создать функцию, которая печатает полное имя:

    <pre>
    <code class="python">
    class Employee:

        def __init__(self, firstname, lastname, pay):
            self.firstname = firstname   # всё равно что "emp_1.firstname = 'Corey'"
            self.lastname = lastname
            self.pay = pay
            self.email = firstname + '.' + lastname + '@company.com'


        def fullname(self, firstname, lastname):
            return '{}_{}'.format(self.firstname, self.lastname)


    emp_1 = Employee('Corey', 'Schaifer', 50000)
    emp_2 = Employee('Test', 'User', 60000)

    # Можно вызвать метод fulltime() у любого экземпляра класса
    print(emp_1.fullname()) # После "fullname" скобочки, потому что это метод, а не атрибут
    
    # "print" выше можно напечатать и другим методом
    print(Employee.fullname(emp_1))
    </code>
    </pre>
    
    
    
    </body>
</html>
